<!DOCTYPE html>

<html>

<head>
    <title>Game</title>
    <script type="text/javascript" src="./build/three.js"></script>
    <script type="text/javascript" src="./build/SceneUtils.js"></script>
    <script type="text/javascript" src="./libs/cannon.js"></script>
    <script type="text/javascript" src="./libs/stats.js"></script>
	<script type="text/javascript" src="./libs/KeyboardState.js"></script>
    <script type="text/javascript" src="./libs/dat.gui.js"></script>
    <style>
        body {
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>

<div id="Stats-output">
</div>
<!-- Div which will hold the Output -->
<div id="WebGL-output">
</div>

	
<!-- Javascript code that runs our Three.js examples -->
<script type="text/javascript">
	
	
	var world, timeStep=1/60;
	var vec3 = new THREE.Vector3();
	var quaternion = new THREE.Quaternion();
	
	var meshes = [];
	var bodies = [];
	var mapBody;
	
	var fixedBodies = [];
	
	function initCannon() {

		world = new CANNON.World();
		world.gravity.set(0,0,0);
		world.broadphase = new CANNON.NaiveBroadphase();
		world.solver.iterations = 10;

    }
	
	
	function updatePhysics() {

        // Step the physics world
 		world.step(timeStep);

		for(i=0; i<bodies.length; i++)
		{
			if(fixedBodies[i])
			{
				vec3=meshes[i].getWorldPosition(vec3);
				bodies[i].position.copy(vec3);
				quaternion=meshes[i].getWorldQuaternion(quaternion);
				bodies[i].quaternion.copy(quaternion);
			}
			else
			{
				meshes[i].position.copy(bodies[i].position);
				meshes[i].quaternion.copy(bodies[i].quaternion);
			}
		}    	
		
    }
	
	var clock = new THREE.Clock(); // clock
	// create a scene, that will hold all our elements such as objects, cameras and lights.
	var scene = new THREE.Scene();
	// create a camera, which defines where we're looking at.
	var camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
	// create a render and set the size
	var webGLRenderer = new THREE.WebGLRenderer({antialias: true});
	var worldTime  = 0;
	// once everything is loaded, we run our Three.js stuff.
	var keyboard = new THREEx.KeyboardState();
	
	webGLRenderer.setClearColor(new THREE.Color(0xffffff));
	webGLRenderer.setSize(window.innerWidth, window.innerHeight);
	webGLRenderer.shadowMap.enabled = true;
	
	// position and point the camera to the center of the scene
	camera.position.x = 0;
	camera.position.y = 12;
	camera.position.z = 20;
	camera.lookAt(new THREE.Vector3(0, 5, 0));
	
	// add the output of the renderer to the html element
	document.getElementById("WebGL-output").appendChild(webGLRenderer.domElement);
		
	window.addEventListener( 'resize', onWindowResize, false );


	//SETTING THE BACKGROUND THEME (WITH TEXTURE)
	var backgroundMesh, backgroundScene, backgroundCamera;

	webGLRenderer.autoClear = false;
	document.body.appendChild( webGLRenderer.domElement );

	var manager = new THREE.LoadingManager();
	manager.onLoad = init;

	var loader = new THREE.TextureLoader( manager );


	loader.crossOrigin = '';

	loader.load('https://vignette.wikia.nocookie.net/seekers/images/a/a1/Night-sky-stars.jpg/revision/latest?cb=20120612222845', function( texture ) { // 'https://upload.wikimedia.org/wikipedia/commons/3/3a/ISS-45_Italy_night_view_%282%29.jpg'
		backgroundMesh = new THREE.Mesh(
	    	new THREE.PlaneBufferGeometry(2,2,0),
			new THREE.MeshBasicMaterial({
	    		map: texture,
			})
			
	    );


		backgroundMesh.material.depthTest = false;
		backgroundMesh.material.depthWrite = false;

		backgroundScene = new THREE.Scene();
		backgroundCamera = new THREE.Camera();
		backgroundScene.add( backgroundCamera );
		backgroundScene.add( backgroundMesh );
	})

	var animate = function () {
		requestAnimationFrame( animate );
		
		webGLRenderer.clear();
		webGLRenderer.render( backgroundScene, backgroundCamera );
		webGLRenderer.render( scene, camera );
	}

	function init() {
		animate();
	} 
	//END OF BACKGROUND SETTINGS


	function onWindowResize()
	{
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		webGLRenderer.setSize( window.innerWidth, window.innerHeight );
	}

	





	//FUNZIONE CHE CREA UN OGGETTO; PUO' ESSERE APPLICATA LA TEXTURE (DA CORREGGERE)
	function createObject(meshgeom,shape,fixed,mass=0, textureUrl) {
		if(textureUrl!= null) {
			var loader = new THREE.TextureLoader;

			loader.crossOrigin = '';

			loader.load( textureUrl, function ( texture ) {
				var material = new THREE.MeshBasicMaterial(
					{map:texture});
				var mesh = new  THREE.Mesh(meshgeom,material);
			});
			var material = new THREE.MeshBasicMaterial({
				map: loader.load(textureUrl)
			});
			//loader.material.depthTest = false;
        	//loader.material.depthWrite = false;
		} else {
			var meshMaterial = new THREE.MeshPhongMaterial();
			var mesh = new THREE.Mesh(meshgeom, meshMaterial);
			mesh.castShadow = true;
			mesh.receiveShadow = true;
		}
		
		

		var body = new CANNON.Body({
			mass: mass
		});
		body.addShape(shape);
		
		meshes.push(mesh);
		bodies.push(body);
		fixedBodies.push(fixed);
		
		return meshes[meshes.length-1];
	}


	// function applyTexture(geometry,url) {
	// 	var loader = new THREE.TextureLoader();

	// 	loader.crossOrigin = '';

	// 	loader.load( url, function ( texture ) {
	// 		var material = new THREE.MeshBasicMaterial(
	// 			{map:texture});
	// 		var mesh = new  THREE.Mesh(geometry,material);
	// 	});
	// }	
	
	function SpotLight()
	{
		//light settings
		var light = new THREE.SpotLight(0xffffff, 0.7, 0, Math.PI/5, 0.5);
		light.position.set( 0, 14, 0 );
		light.castShadow = true;
		light.target.position.set (0, 0, 0);
		scene.add( light );

		//visualize schematic light wires
		var helper = new THREE.SpotLightHelper( light );
		scene.add( helper );
		scene.add( light.target );

		return light;
		
	}

	

	var Ambient_Light = new THREE.AmbientLight(0xffffff, 0.05);
	scene.add(Ambient_Light);
	

	initCannon();
	
</script>
	
	
	
------------------------------------------------------------------------------------------------------------------
	
	
	
<script type="text/javascript">

	//****************************************************************************//
	//*****************************-ROBOT-SCRIPT**********************************//
	//*********************************START**************************************//
	//****************************************************************************//

	var headTime = 0;
	var spyderTime = 0;
	var velocity=0;
	var velocityDir=0;
	var maxvelocity= 6.0;
	var robotScale=1.7;
	
	// create meshes
	var robot = new THREE.Group();
	robot.position.set(0,robotScale,0);
	
	var rotator = new THREE.Object3D();

	var sphere = new THREE.SphereGeometry(robotScale, 8, 8);

	//APPLYING TEXTURE TO THE BODY OF THE ROBOT
	//applyTexture(sphere,'https://upload.wikimedia.org/wikipedia/commons/d/d0/Color-yellow.JPG');
	
	var sphereObject = createObject(sphere,  new CANNON.Sphere(robotScale), true, 0, 'https://upload.wikimedia.org/wikipedia/commons/d/d0/Color-yellow.JPG' );

	
	var box = new THREE.BoxGeometry(0.8*robotScale,0.5*robotScale,0.5*robotScale);

	//APPLYING TEXTURE TO THE BODY OF THE ROBOT
	//applyTexture(box, 'http://2.bp.blogspot.com/-32hGBWeMxJc/TnEK1y8XnFI/AAAAAAAAAUM/AzKULdd6nJc/s1600/Dark_Red_Background.jpg' );
	var headObject = createObject(box, new CANNON.Box(new CANNON.Vec3((0.8*robotScale)/2,(0.5*robotScale)/2,(0.5*robotScale)/2)), true, 0, 'http://2.bp.blogspot.com/-32hGBWeMxJc/TnEK1y8XnFI/AAAAAAAAAUM/AzKULdd6nJc/s1600/Dark_Red_Background.jpg' );
	headObject.position.set(0,1.3*robotScale,0);
	
	
	var upLegsObject = [];
	var downLegsObject = [];
	var upLegsLength =1.3;
	var downLegsLength =1;
	var knees = [];
	var feet = [];
	var upLegsInitialRotation = [[]];
	
	var rotationAngles = [0,0,-Math.PI/8,Math.PI];
	
	var sphereId = 0;
	var headId = 1;
	var upLegsId = 2;
	var kneesId = 3;	
	var sign = 1;
	var sign1 = 1;
	var sign2 = 1;
	var sign3 = 0;
	var sign4 = 0;
	
	
	for(var i =0; i<8; i++)
	{
		upLegsObject[i]= createObject(new THREE.CylinderGeometry(0.2*robotScale,0.1*robotScale,upLegsLength*robotScale,3),  new CANNON.Cylinder(0.2*robotScale,0.1*robotScale,upLegsLength*robotScale,3), true);
		knees[i]= new THREE.Object3D();
		downLegsObject[i]= createObject(new THREE.CylinderGeometry(0.07*robotScale,0.2*robotScale,downLegsLength*robotScale,3),  new CANNON.Cylinder(0.07*robotScale,0.2*robotScale,downLegsLength*robotScale,3), true);
		feet[i]= new THREE.Object3D();
	}
		
	function initializeLegs()
	{
		for(var i=0; i<8; i++)
		{
			upLegsObject[i].position.set(0,-0.45*robotScale,0);
			upLegsObject[i].rotation.set(0,0,Math.PI/2);
			
			if(i<4)
				upLegsObject[i].rotateX((Math.PI/5)*(i+1));
			
			else
				upLegsObject[i].rotateX((-Math.PI/5)*(i-3));
			
			upLegsObject[i].rotateZ(rotationAngles[upLegsId] = -Math.PI/8);
			
			knees[i].position.set(0,(upLegsLength/2)*robotScale,0);
			knees[i].rotation.set(0,0,rotationAngles[kneesId] = Math.PI);

			downLegsObject[i].position.set(0,(downLegsLength/2)*robotScale,0);

			feet[i].position.set(0,(downLegsLength/2)*robotScale,0);
			feet[i].rotation.set(0,0,0);
			
			upLegsInitialRotation[i] = upLegsObject[i].rotation.clone();
		}
	}
	
	initializeLegs();
	
	
	var counter=0;
	var counter1=0;
	var counter2=0;
	var headIsRotating=false;
	var robotIsMoving;
	var transformation= 0;
	var dampingX, dampingY, dampingZ;
	var step=false;
	var step1=false;
	var step2=false;
	var transitions=0;
	var spyderMode=false;
	var legId;
	var robotHeight= robotScale+(0.2*robotScale); //height of the robot during spydermode

	
	//var robot = new THREE.Group();
	//robot.add( neck );
	robot.add( sphereObject );
	robot.add( headObject );
	robot.add( rotator );
	
	var legs = new THREE.Group();
	for(var i =0; i<8; i++)
	{
		legs.add(upLegsObject[i]);
		legs.add(downLegsObject[i]);
	}
	
	//add the robot to the scene
	rotator.add(headObject);
	scene.add(robot);

	//render();
	function velocityCalculation()
	{
		if(keyboard.pressed("A") & keyboard.pressed("D"))
		{
			if (Math.abs(velocity)>0.1)
			{
				velocity = velocity/1.1;
			}
			else
				velocity = 0;
			velocityDir = 0;
		}
		else if(keyboard.pressed("D"))
		{
			if (velocity<maxvelocity)
			{
				velocity += 0.25;
				velocityDir =1;
			}
		}
		else if(keyboard.pressed("A"))
		{
			if (velocity>-maxvelocity)
			{
				velocity -= 0.25;
				velocityDir =-1;
			}
		}
		else
		{
			if (Math.abs(velocity)>0.1)
			{
				velocity = velocity/1.1;
			}
			else
				velocity = 0;
			velocityDir = 0;
		}
		
	}
	
	function robotSelfAnimation()
	{
		if ( !headIsRotating && Math.random() >= 0.99)
			{
				headIsRotating=true;
				
				if(Math.random() >= 0.5)
					sign = -sign;
				counter=0;
			}

		if (headIsRotating && Math.abs(counter)<2*Math.PI)
			{
				counter += sign * 0.4;
				headObject.rotation.y = counter;
			}
		else
			{
				headIsRotating = false;
			}
		
		
		rotator.rotation.z= dampingZ = sign1*0.5*Math.sin(2*headTime);
		rotator.rotation.x= dampingX = sign2*0.5*Math.sin(3*headTime);
		
		if(spyderMode && !robotIsMoving)
		{
			robot.translateY(-0.01*(robotScale/3)*(Math.sin(3*spyderTime)));
			for(var i=0; i<8; i++)
			{
				upLegsObject[i].rotateZ(-0.005*(Math.sin(3*spyderTime)));
				knees[i].rotateZ(0.005*(Math.sin(3*spyderTime)));
			}
			spyderTime+=0.015;
		}
		

	}
	
	function robotRoll() 
	{	
		sphereObject.rotation.z = rotationAngles[sphereId] -= 0.05*velocity;
		robot.translateX(0.05*velocity*robotScale); 
		
		rotator.position.y = 0.1*(Math.abs(velocity))*robotScale;
		
		headObject.rotation.z = 0.3*velocity;
		
		
		if (Math.abs(velocity)==0)	
			robotSelfAnimation();

		else
		{
			rotator.rotation.z = -0.2*velocity+dampingZ;
			rotator.rotation.x = dampingX = dampingX/1.2;
			dampingZ=dampingZ/1.12;
			headTime=0;
			if(Math.random() >= 0.5)
			{
				sign1= -sign1;
			}if(Math.random() >= 0.5)
			{
				sign2= -sign2;
			}
		}
		
		if (headIsRotating && velocity!=0)
		{
			if(counter<2*Math.PI)
			{
				if (headIsRotating && counter<2*Math.PI)
			{
				counter += 0.4;
				headObject.rotation.y = counter;
			}
			else
			{
				headIsRotating = false;
				counter = 0;
			}
			}
		}
	}
		
	function headAtCenter()
	{
		rotator.rotation.z= rotator.rotation.z/1.1;
		rotator.rotation.x= rotator.rotation.x/1.1;
		head.rotation.y = head.rotation.y/1.1

	}
	
	function ballToLegsTransformation()
	{
		spyderTime=0;
		scene.add(legs);
		robot.add(legs);
		robotSelfAnimation();

		for(var i =0; i<8; i++)
		{
			upLegsObject[i].add(knees[i]);
			knees[i].add(downLegsObject[i]);
			downLegsObject[i].add(feet[i]);
		}
		
		if (upLegsObject[0].position.y < -0.1*robotScale)
		{
			for(var i =0; i<8; i++)
				upLegsObject[i].translateY(0.1);
		}
		
		else if(rotationAngles[kneesId] > 0.5*Math.PI)
		{
			for(var i =0; i<8; i++)
				knees[i].rotation.z = rotationAngles[kneesId];
			
			rotationAngles[kneesId] -= 0.06;
		}
		
		else if(feet[0].getWorldPosition(vec3).y>0 && !step)
		{
				for(var i =0; i<8; i++)
				{
					upLegsObject[i].rotateZ(0.01);
				}
		}
		
		else if(robot.position.y<robotHeight)
		{
			step=true;
			if(feet[0].getWorldPosition(vec3).y<=0 || feet[1].getWorldPosition(vec3).y<=0)
				robot.translateY(0.02*(robotScale/3));
			else
			{
				for(var i=0; i<8; i++)
				{
					upLegsObject[i].rotateZ(0.01);
					knees[i].rotateZ(-0.01);
				}
			}
		}
		
		else
		{
			step=false;
			transformation=2;
			spyderMode=true;
		}
		
	}
	
	function legsAnimation()
	{
		function legStep()
		{
			
			
			if (sign3==0)
			{
				if(velocityDir>0)
					sign3=1;
				else if (velocityDir<0)
					sign3=-1;
				
			}
			else
			{
				var c=(sign3+1)/2;
				robotIsMoving=true;
				if (counter1<4)
				{
					upLegsObject[0+c].rotateZ(-0.15);
					upLegsObject[0+c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
					upLegsObject[2+c].rotateZ(-0.15);
					upLegsObject[2+c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
					upLegsObject[4+c].rotateZ(-0.15);
					upLegsObject[4+c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
					upLegsObject[6+c].rotateZ(-0.15);
					upLegsObject[6+c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
					
					upLegsObject[3*c].rotateZ(0.075);
					upLegsObject[3*c+4].rotateZ(0.075);
					upLegsObject[3*c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.05);
					upLegsObject[3*c+4].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.05);
					knees[3*c].rotateZ(-0.17);
					knees[3*c+4].rotateZ(-0.17);
					
					counter1++;
					
					if(step1)
					{
						upLegsObject[1-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
						upLegsObject[3-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
						upLegsObject[5-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
						upLegsObject[7-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
						
						robot.translateX(sign3*0.1*robotScale);
					}
				}
				else if(counter1<8)
				{
					upLegsObject[0+c].rotateZ(0.15);
					upLegsObject[0+c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
					upLegsObject[2+c].rotateZ(0.15);
					upLegsObject[2+c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
					upLegsObject[4+c].rotateZ(0.15);
					upLegsObject[4+c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
					upLegsObject[6+c].rotateZ(0.15);
					upLegsObject[6+c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);

					counter1++;
					
					upLegsObject[3*c].rotateZ(0.075);
					upLegsObject[3*c+4].rotateZ(0.075);
					upLegsObject[3*c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.05);
					upLegsObject[3*c+4].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.05);
					knees[3*c].rotateZ(-0.17);
					knees[3*c+4].rotateZ(-0.17);
										
					if(step1)
					{
						upLegsObject[1-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
						upLegsObject[3-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
						upLegsObject[5-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
						upLegsObject[7-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
						
						robot.translateX(sign3*0.1*robotScale);
					}
					
					if(velocityDir==sign3)
						step2=true;
					if(velocityDir==0 || velocityDir!=sign3 || transformation==3)
						step2=false;
				}
				else if(counter1<12)
				{
					upLegsObject[0+c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
					upLegsObject[2+c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
					upLegsObject[4+c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
					upLegsObject[6+c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
					
					upLegsObject[1-c].rotateZ(-0.15);
					upLegsObject[3-c].rotateZ(-0.15);
					upLegsObject[5-c].rotateZ(-0.15);
					upLegsObject[7-c].rotateZ(-0.15);
					
					upLegsObject[3*c].rotateZ(-0.075+(0.01*(counter1-8)));
					upLegsObject[3*c+4].rotateZ(-0.075+(0.01*(counter1-8)));
					upLegsObject[3*c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.05);
					upLegsObject[3*c+4].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.05);
					knees[3*c].rotateZ(0.15);
					knees[3*c+4].rotateZ(0.15);
					
					if(step2)
					{
						upLegsObject[1-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
						upLegsObject[3-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
						upLegsObject[5-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
						upLegsObject[7-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
					}

					robot.translateX(sign3*0.1*robotScale);
					counter1++;
				}
				else if(counter1<16)
				{
					upLegsObject[0+c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
					upLegsObject[2+c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
					upLegsObject[4+c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
					upLegsObject[6+c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
					
					upLegsObject[1-c].rotateZ(0.15);
					upLegsObject[3-c].rotateZ(0.15);
					upLegsObject[5-c].rotateZ(0.15);
					upLegsObject[7-c].rotateZ(0.15);
					
					upLegsObject[3*c].rotateZ(-0.075-(0.01*(counter1-12)));
					upLegsObject[3*c+4].rotateZ(-0.075-(0.01*(counter1-12)));
					upLegsObject[3*c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.05);
					upLegsObject[3*c+4].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.05);
					knees[3*c].rotateZ(0.19);
					knees[3*c+4].rotateZ(0.19);
					
					if(step2)
					{
						upLegsObject[1-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
						upLegsObject[3-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
						upLegsObject[5-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
						upLegsObject[7-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
					}
					
					
					robot.translateX(sign3*0.1*robotScale);
					counter1++;
					
					if(velocityDir==sign3)
						step1=true;
					if(velocityDir==0 || velocityDir!=sign3 || transformation==3)
						step1=false;
				}
				else if(!step2)
				{
					transitions=0;
					counter1=0;
					sign3=0;
					robotIsMoving=false;
					step1=false;
					step2=false;
				}
				else if(counter1<20 && !step1)
				{
					
					upLegsObject[1-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
					upLegsObject[3-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
					upLegsObject[5-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
					upLegsObject[7-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
					
					upLegsObject[c].rotateZ(-0.15);
					upLegsObject[2+c].rotateZ(-0.15);
					upLegsObject[4+c].rotateZ(-0.15);
					upLegsObject[6+c].rotateZ(-0.15);
					
					robot.translateX(sign3*0.1*robotScale);
					counter1++;
					
				}
				else if(counter1<24 && !step1)
				{
					upLegsObject[1-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
					upLegsObject[3-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -sign3*0.1);
					upLegsObject[5-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
					upLegsObject[7-c].rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), sign3*0.1);
					
					upLegsObject[0+c].rotateZ(0.15);
					upLegsObject[2+c].rotateZ(0.15);
					upLegsObject[4+c].rotateZ(0.15);
					upLegsObject[6+c].rotateZ(0.15);
					
					robot.translateX(sign3*0.1*robotScale);
					counter1++;
				}
				else if(!step1)
				{
					transitions=0;
					counter1=0;
					sign3=0;
					robotIsMoving=false;
					step1=false;
					step2=false;
				}
				else
				{
					counter1=0;
					robot.translateX(sign3*0.1*robotScale);
				}
				
			}
		}
		
		
		switch(transitions)
		{
			case 0:
				if (velocityDir!=0)
					transitions=1;
				
				robotSelfAnimation();
				
				if(keyboard.pressed("space"))
					transitions=2;
				
				break;
			case 1:
				legStep();
				robotSelfAnimation();
				
				break;
			case 2:
				climb();
				break;
		}
	}
	
	function legsToBallTransformation()
	{
		spyderMode=false;
		robotSelfAnimation();
		if(robot.position.y>robotScale)
		{
			if(feet[0].getWorldPosition(vec3).y>0)
				robot.translateY(-0.02*(robotScale/3));
			else
				for(var i=0; i<8; i++)
				{
					upLegsObject[i].rotateZ(-0.01);
					knees[i].rotateZ(0.01);
				}
		}
		else if (upLegsObject[0].rotation.z > upLegsInitialRotation[0].z)
		{
			for(var i =0; i<8; i++)
				upLegsObject[i].rotateZ(-0.01);
		}
		else if(rotationAngles[kneesId] < Math.PI)
		{
			for(var i =0; i<8; i++)
				knees[i].rotation.z = rotationAngles[kneesId];
			rotationAngles[kneesId] += 0.06;

		}
		else if(upLegsObject[0].position.y > -0.33*robotScale)
		{
			for(var i =0; i<8; i++)
				upLegsObject[i].translateY(-0.1);
		}
		else
		{
			transformation=0;
			scene.remove(legs);
			robot.remove(legs);
			initializeLegs()
		}
		
		
	}
	
	//Animation of the robot
	function robotAnimation() {

		headTime += 0.015;
		
		camera.position.x = robot.position.x+velocity/2;

		if(keyboard.pressed("1"))
		{
			if(transformation==0)
				transformation = 1;
			else if (transformation==2)
				transformation = 3;
		}
		
		switch (transformation)
		{
			case 0:
				velocityCalculation();
				robotRoll();
				break;
				
			case 1:
				if (Math.abs(velocity)>0.3)
				{
					velocity=velocity/1.1;
					robotRoll();
				}
				else
				{
					ballToLegsTransformation();
					velocity=velocity/1.1;
				}
				break;
				
			case 2:
				velocityCalculation();
				legsAnimation();
				break;
				
			case 3:
				if (robotIsMoving)
				{
					velocityCalculation();
					robotSelfAnimation();
					legsAnimation();
				}
				else
				{
					transitions=0;
					legsToBallTransformation();
					velocity=velocity/1.1;
				}
				break;
				
		}
		// render using requestAnimationFrame
		requestAnimationFrame(robotAnimation);
		webGLRenderer.render(scene, camera);
	}
	
	robotAnimation();
	
	//****************************************************************************//
	//*****************************-ROBOT-SCRIPT**********************************//
	//**********************************END***************************************//
	//****************************************************************************//
	
</script>
	
	
<script type="text/javascript">
	
	//***************************************************************************//
	//*****************************-MAP SCRIPT-**********************************//
	//*********************************START*************************************//
	//***************************************************************************//
	
	var doorsArray = [];
	var roomHasFrontDoor = [];
	var roomHasBackDoor = [];
	var boxLength =1.7;
	var boxDepth = 1.1;
	
	//-------------------------------------------------------------//
	//----------------------CREATE-OBJECTS-------------------------//
	//-------------------------------------------------------------//

		
	//CREATE A WALL
	function createWall(wallWidth, roomHeight)
	{
		var wallObject=createObject(new THREE.BoxGeometry(wallWidth,roomHeight,0.1), new CANNON.Box(new CANNON.Vec3(wallWidth/2,roomHeight/2,0.1/2)), true )
		return wallObject;
	}
	
	//CREATE A WINDOW
	function createWindow(starshipWindowWidth, starshipWindowHeight)
	{
		var starshipWindowGroup = new THREE.Group();
		
		var bottomSObject = createObject(new THREE.BoxGeometry(starshipWindowWidth,2,2), new CANNON.Box(new CANNON.Vec3(starshipWindowWidth/2,1,1)), true );
		bottomSObject.position.set(0,-starshipWindowHeight/2+1,0);
		var topSObject = createObject(new THREE.BoxGeometry(starshipWindowWidth,2,2), new CANNON.Box(new CANNON.Vec3(starshipWindowWidth/2,1,1)), true );
		topSObject.position.set(0,starshipWindowHeight/2-1,0);
		var leftSObject = createObject(new THREE.BoxGeometry(2,starshipWindowHeight,2), new CANNON.Box(new CANNON.Vec3(1,starshipWindowHeight/2,1)), true );
		leftSObject.position.set(-starshipWindowWidth/2,0,0);
		var rightSObject = createObject(new THREE.BoxGeometry(2,starshipWindowHeight,2), new CANNON.Box(new CANNON.Vec3(1,starshipWindowHeight/2,1)), true );
		rightSObject.position.set(starshipWindowWidth/2,0,0)
		
		starshipWindowGroup.add(bottomSObject, topSObject, leftSObject, rightSObject);

		return starshipWindowGroup;
	}
	
	//CREATE A DOOR
	function createDoor(doorHeight, doorWidth)
	{
		var doorObject = createObject(new THREE.BoxGeometry(1.2,doorHeight,doorWidth), new CANNON.Box(new CANNON.Vec3(1.2/2,doorHeight/2,doorWidth/2)), true );
		return doorObject;
	}
	
	
	//CREATE A WALL FOR DOOR
	function createWallForDoor(depth,height)
	{
		var doorWidth=8;
		var doorHeight=10;
		
		var wall1Object = createObject(new THREE.BoxGeometry(2,height,(depth-doorWidth)/2), new CANNON.Box(new CANNON.Vec3(1,height/2,(depth-doorWidth)/4)), true);
		wall1Object.position.set(0,height/2,-(doorWidth/2)-((depth-doorWidth)/4));
		var wall2Object = createObject(new THREE.BoxGeometry(2,height,(depth/2)-(doorWidth/2)), new CANNON.Box(new CANNON.Vec3(1,height/2,((depth/2)-(doorWidth/2))/2)), true);
		wall2Object.position.set(0,height/2,+(doorWidth/2)+((depth-doorWidth)/4));
		var wall3Object = createObject(new THREE.BoxGeometry(2,height-doorHeight,doorWidth), new CANNON.Box(new CANNON.Vec3(1,(height-doorHeight)/2,doorWidth/2)), true);
		wall3Object.position.set(0,height-((height-doorHeight)/2),0);
		
		
		
		var wallForDoorGroup = new THREE.Group();
		wallForDoorGroup.add(wall1Object,wall2Object,wall3Object);
		
		return wallForDoorGroup;
	}

	//CREATE A SECURITY CAMERA
	function createSurveillanceCamera()
	{
		var surveillanceCameraGroup = new THREE.Group();
		
		var boxObject = createObject(new THREE.BoxGeometry(boxLength,boxDepth,boxDepth), new CANNON.Box(new CANNON.Vec3(boxLength/2,boxDepth/2,boxDepth/2)), true);
		
		var eyeObject = createObject(new THREE.CylinderGeometry(boxDepth*0.4,boxDepth*0.4,boxLength/3,8),  new CANNON.Cylinder(boxDepth*0.4,boxDepth*0.4,boxLength/3,8), true );
		eyeObject.rotation.z=Math.PI/2;
		eyeObject.position.x=-boxLength/2;
		
		surveillanceCameraGroup.add(boxObject,eyeObject);
		surveillanceCameraGroup.rotation.z=Math.PI/6;
		
		return surveillanceCameraGroup;
	}
	function createSubstainForSurvaillanceCamera()
	{
		var substainForSurveillanceCamera = new THREE.Group();
		
		var stick1Object = createObject(new THREE.CylinderGeometry(boxDepth*0.2,boxDepth*0.2,boxLength*0.8,3),  new CANNON.Cylinder(boxDepth*0.2,boxDepth*0.2,boxLength*0.8,3), true  );
		
		var stick2Object = createObject(new THREE.CylinderGeometry(boxDepth*0.2,boxDepth*0.2,boxLength*1.5,3),  new CANNON.Cylinder(boxDepth*0.2,boxDepth*0.2,boxLength*1.5,3), true );
		stick2Object.position.set(boxLength/2,+boxLength/10,0);
		stick2Object.rotation.z=-Math.PI/4;
		
		substainForSurveillanceCamera.add(stick1Object,stick2Object);
		substainForSurveillanceCamera.position.y=-boxLength/2;

		
		return substainForSurveillanceCamera;
	}

	
	//-----------------------------------------------------//
	//-----------------------ROOMS-------------------------//
	//-----------------------------------------------------//

	
	//CREATE A STARSHIP'S ROOM (WINDOW OR WALL) (COLUMN OR DOOR)
	function createStandardRoom (window,column, num)
	{
		var standardRoom = new THREE.Group();
		
		//room size
		var roomWidth = 60;
		var roomDepth = 39;
		var roomHeight = 15;
		
		var floorObject = createObject(new THREE.BoxGeometry(roomWidth,roomDepth,0.1),	new CANNON.Box(new CANNON.Vec3(roomWidth/2,roomDepth/2,0.1/2)), true);
		floorObject.rotation.set(-Math.PI/2,0,0);
		standardRoom.add(floorObject);

		//a starship window and walls
		if(window)
		{
			var pieceOfWallWidth = roomWidth/8;
			var starshipWindowWidth = roomWidth-(2*pieceOfWallWidth);
			var starshipWindowHeight = roomHeight;

			var starshipWindowGroup = createWindow(starshipWindowWidth, starshipWindowHeight);
			starshipWindowGroup.position.set(0,starshipWindowHeight/2,-roomDepth/2);
			standardRoom.add(starshipWindowGroup);

			var wallRObject = createWall(pieceOfWallWidth,roomHeight);
			wallRObject.position.set((starshipWindowWidth/2)+(pieceOfWallWidth/2),roomHeight/2,-roomDepth/2);
			var wallLObject = createWall(pieceOfWallWidth,roomHeight);
			wallLObject.position.set(-(starshipWindowWidth/2)-(pieceOfWallWidth/2),roomHeight/2,-roomDepth/2);
			standardRoom.add(wallRObject, wallLObject);
		}
		else
		{
			var wallObject = createWall(roomWidth,roomHeight);
			wallObject.position.set(0,roomHeight/2,-roomDepth/2);
			standardRoom.add(wallObject);
		}

		//ceiling
		var ceilingObject = createObject(new THREE.BoxGeometry(roomWidth,roomDepth,0.1), new CANNON.Box(new CANNON.Vec3(roomWidth/2,roomDepth/2,0.1/2)), true);
		ceilingObject.rotation.set(Math.PI/2,0,0);
		ceilingObject.position.y=roomHeight;
		standardRoom.add(ceilingObject);

		//column
		if(column)
		{
			var columnObject = createObject(new THREE.BoxGeometry(5,roomHeight,4), new CANNON.Box(new CANNON.Vec3(5/2,roomHeight/2,4/2)), true);
			columnObject.position.set(roomWidth/2,roomHeight/2,-roomDepth/2+2);
			standardRoom.add(columnObject);
		}
		//wall for door
		else
		{
			var wallForDoorGroup = createWallForDoor(roomDepth,roomHeight);
			wallForDoorGroup.position.x=roomWidth/2;
			standardRoom.add(wallForDoorGroup);
			
			var door = createDoor(10, 8);
			door.position.set(30+60*num,5,0);
			
			doorsArray[num]=door;
			roomHasBackDoor[num+1]=true;
			
			scene.add(doorsArray[doorsArray.length-1]);
			
		}
		
		standardRoom.position.x=60*(num);
		roomLight(num);
		return standardRoom;

	}
	
	//CREATE A CIRCULAR ROOM
	function createCircleRoom(column,num)
	{
	
		var circleRoom = new THREE.Group();
	
		var numOfSegments = 32;
		var radius = 32;
		var roomHeight = 15;
		
		//floor circle
		var floorObject = createObject(new THREE.CircleGeometry(radius,numOfSegments), new CANNON.Box(new CANNON.Vec3(radius,radius,0.1/2)), true);
		floorObject.rotation.set(-Math.PI/2,0,0);
		floorObject.position.y=0.05;
		circleRoom.add(floorObject);
		
		//circular wall
		var wallGroup = new THREE.Group();
		var wallPieces = [];
		for(i=3; i<numOfSegments-3; i++)
		{
			wallPieces[i]=createWall((radius*Math.PI)/numOfSegments,roomHeight);
			wallPieces[i].rotation.y=Math.PI/2-(i*Math.PI/numOfSegments);
			wallPieces[i].translateZ(-radius);
			wallPieces[i].position.y=roomHeight/2;
			wallGroup.add(wallPieces[i]);
		}
		circleRoom.add(wallGroup);
		
		//ceiling
		var ceilingObject = createObject(new THREE.CircleGeometry(radius,numOfSegments), new CANNON.Box(new CANNON.Vec3(radius/2,radius/2,0.1/2)), true);
		ceilingObject.rotation.set(Math.PI/2,0,0);
		ceilingObject.position.y=roomHeight-0.05;
		circleRoom.add(ceilingObject);

		
		//column
		if(column)
		{
			var columnObject = createObject(new THREE.BoxGeometry(5,roomHeight,4),  new CANNON.Box(new CANNON.Vec3(5/2,roomHeight/2,4/2)), true);
			columnObject.position.set(radius-2,roomHeight/2,-39/2+2);
			circleRoom.add(columnObject);
		}
		//wall for door
		else
		{
			var wallForDoorGroup = createWallForDoor(39,roomHeight);
			wallForDoorGroup.position.x=radius-2;
			circleRoom.add(wallForDoorGroup);
			
			var door = createDoor(10, 8);
			door.position.set(30+60*num,5,0);
			
			doorsArray[num]=door;
			roomHasBackDoor[num+1]=true;
			
			scene.add(doorsArray[doorsArray.length-1]);
			
		}
		
		circleRoom.position.x= num*60;
		return circleRoom;
		
	}
	

//-----------------TUBE-LIGHT-----------------------//

	function roomLight(num)
	{
		var tubeGeometry = new THREE.CylinderBufferGeometry( 0.3, 0.3, 30 );
		tubeLight = new THREE.PointLight( 0x0000ff, 0.7, 100, 2 );
		tubeMat = new THREE.MeshStandardMaterial( {
		emissive: 0x0000ff,
		emissiveIntensity: 1,
		color: 0x000000
	});

	tubeLight.add( new THREE.Mesh( tubeGeometry, tubeMat ) );
	tubeLight.position.set( 60*(num), 15, 0 );
	tubeLight.castShadow = true;

	tubeLight.rotateZ (Math.PI/2);
	scene.add( tubeLight );

	}

	

//-------------------------------------------------------------//


	//--------------------------------------------------------------//
	//-----------------------CREATE-OBJECTS-------------------------//
	//--------------------------------------------------------------//
	
	//create the edge
	var bound = createObject(new THREE.BoxGeometry( 0.01, 0.01, 0.01 ), new CANNON.Box ( new CANNON.Vec3(3000,30,0.005)), true );
	bound.position.z=20;
	//bound.rotateZ(-Math.PI/2);
	scene.add(bound);
	
	//create the rooms
	var rooms = [];
	rooms[0] = createStandardRoom(true,false,0);
	rooms[1] = createStandardRoom(false,false,1);
	rooms[2] = createStandardRoom(true,false,2);
	rooms[3] = createCircleRoom(false,3);
	
	
	for(i=0; i<rooms.length; i++)
		scene.add(rooms[i]);
	
	for(i=0; i<bodies.length; i++)
		{
			world.addBody(bodies[i]);
		}
	
	//create the security camera
	var surveillanceCameraGroup = createSurveillanceCamera();	
	var substainForSurvaillanceCamera = createSubstainForSurvaillanceCamera();
	var securityCamera = new THREE.Group();
	securityCamera.position.set( 30 - 2.2, 13, 0 );
	securityCamera.add(surveillanceCameraGroup, substainForSurvaillanceCamera);
	scene.add(securityCamera);
	
	
	//---------------------------------------------------------//
	//-----------------------ANIMATION-------------------------//
	//---------------------------------------------------------//
	
	
	function doorsAnimation()
	{
		var currentRoom = Math.floor((robot.position.x+30)/60);
		
		
		if (roomHasBackDoor[currentRoom+1])
		{
			if (robot.position.x>17+(60*currentRoom))
			{
				if(doorsArray[currentRoom].position.z>-7)
				{
					doorsArray[currentRoom].translateZ(-0.5);
				}
			}
			else
				if(doorsArray[currentRoom].position.z<=0)
				{
					doorsArray[currentRoom].translateZ(0.5);
				}
		}
		if (roomHasBackDoor[currentRoom])
			if (robot.position.x<(60*(currentRoom-1))+47)
			{
				if(doorsArray[currentRoom-1].position.z>-7)
				{
					doorsArray[currentRoom-1].translateZ(-0.5);
				}
			}
			else
				if(doorsArray[currentRoom-1].position.z<=0)
				{
					doorsArray[currentRoom-1].translateZ(0.5);
				}
	}
	
	function surveillanceCameraAnimation()
	{
		surveillanceCameraGroup.rotation.y=(Math.PI/6)*Math.sin(0.7*worldTime);
	}
	function mapAnimation()
	{
		worldTime += clock.getDelta();
		doorsAnimation();
		surveillanceCameraAnimation();
		updatePhysics();
		requestAnimationFrame(mapAnimation);
		
		if(keyboard.pressed("N"))
			world.gravity.set(0,0,-300);
			
		if(keyboard.pressed("R"))
		{
			fixedBodies[4]=false;
			//fixedBodies[4+8]=false;
			
		}
		
		if(keyboard.pressed("F"))
		{
			
			var testMesh = createObject(new THREE.BoxGeometry( 2, 2, 2 ), new CANNON.Box ( new CANNON.Vec3(1,1,1)), false, 10 );
			bodies[bodies.length-1].position.set(45,7,0);
			testMesh.position.set(bodies[bodies.length-1].position);
			bodies[bodies.length-1].velocity.set(10*(Math.random()-0.5),10*(Math.random()-0.5),10*(Math.random()-0.5));
			bodies[bodies.length-1].velocityDamping = 0.0;
			world.addBody(bodies[bodies.length-1]);
			scene.add(testMesh);
		}
			
	}
	
	mapAnimation();

	//***************************************************************************//
	//*****************************-MAP SCRIPT-**********************************//
	//**********************************END**************************************//
	//***************************************************************************//
</script>
	
	

	
<script type="text/javascript">
//SCRIPT PER IL RENDERING
	webGLRenderer.render(scene, camera);
</script>

	
	
	
</body>
</html>